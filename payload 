# src/search_steps/impls/generate_answer/build_payload.py
from __future__ import annotations
from pathlib import Path
from typing import List
import re

INSTRUCTIONS = (
    "Beantworten Sie die folgende Frage ausschließlich anhand der bereitgestellten Dateien. "
    "Wenn eine Antwort gefunden wird, geben Sie nur die Antwort und den zugehörigen Pfad aus. "
    "Keine zusätzlichen Erklärungen oder Kommentare. Falls keine Antwort in den Dateien "
    "enthalten ist, geben Sie nichts aus."
)

def _read_text_safe(p: Path) -> str:
    try:
        return p.read_text(encoding="utf-8")
    except Exception:
        return p.read_text(encoding="utf-8", errors="ignore")

def _gather_files(copy_dir: str, k: int) -> List[Path]:
    d = Path(copy_dir)
    if not d.exists():
        return []
    files = [
        p for p in d.iterdir()
        if p.is_file()
        and p.name != "manifest.json"
        and p.suffix.lower() not in {".json", ".png", ".jpg", ".jpeg", ".gif", ".pdf"}
    ]
    files.sort()
    return files[:k]

def _normalize_newlines(text: str) -> str:
    # normalize line endings
    text = text.replace("\r\n", "\n").replace("\r", "\n")
    # collapse 2+ blank lines to exactly one blank line
    text = re.sub(r"\n\s*\n+", "\n\n", text)
    # strip leading/trailing blank lines
    return text.strip("\n")

def _wrap_brackets(text: str) -> str:
    return "[\n" + text + "\n]"

def make_payload_text(copy_dir: str, query: str, k: int = 20, max_chars: int = 18_000) -> str:
    """
    Build payload:
      - Header + Frage + Dateien:
      - For each file: `file:i.` then the file content wrapped in `[ ... ]`
      - Single blank line between blocks
      - No duplicate provenance, we use file content as-is
      - Global char cap (always closes the bracket)
    """
    header = f"{INSTRUCTIONS}\n\nFrage: [{query} ]\n\nDateien:\n"
    remaining = max_chars - len(header)
    if remaining <= 0:
        return header.rstrip() + "\n"

    blocks: List[str] = []
    for i, p in enumerate(_gather_files(copy_dir, k), start=1):
        raw = _read_text_safe(p)
        if not raw:
            continue
        text = _normalize_newlines(raw)

        # Start building the block (we add exactly one trailing blank line later)
        block_prefix = f"file:{i}.\n"
        bracket_open  = "[\n"
        bracket_close = "\n]"
        fixed_overhead = len(block_prefix) + len(bracket_open) + len(bracket_close) + 1  # +1 for the final newline

        # If not enough room for any content + overhead, stop.
        if remaining <= fixed_overhead:
            break

        # Budget for the body
        body_budget = remaining - fixed_overhead

        if len(text) > body_budget:
            # Keep head and tail, but ensure we can still place ellipsis and close bracket
            head = text[: int(body_budget * 0.85)]
            tail = text[-max(0, int(body_budget * 0.10)) :]
            # Ensure total <= body_budget (reserve 4 for "\n...\n")
            ellipsis = "\n...\n" if body_budget >= 4 else ""
            body = (head + ellipsis + tail)[:body_budget]
        else:
            body = text

        block = block_prefix + bracket_open + body + bracket_close + "\n"  # exactly one blank line after
        blocks.append(block)
        remaining -= len(block)
        if remaining <= 0:
            break

    payload = header + "".join(blocks)
    # Final safety trim while keeping structure; if cut, try to end on newline.
    if len(payload) > max_chars:
        payload = payload[: max_chars - 1] + "\n"
    return payload

def make_payload_file(copy_dir: str, query: str, out_file: str,
                      k: int = 20, max_chars: int = 18_000) -> str:
    payload = make_payload_text(copy_dir=copy_dir, query=query, k=k, max_chars=max_chars)
    out_path = Path(out_file)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(payload, encoding="utf-8", newline="\n")
    return str(out_path)