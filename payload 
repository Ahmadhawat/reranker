# src/search_steps/impls/generate_answer/build_payload.py
from __future__ import annotations
from pathlib import Path
from typing import List
import re

INSTRUCTIONS = (
    "Beantworten Sie die folgende Frage ausschließlich anhand der bereitgestellten Dateien. "
    "Wenn eine Antwort gefunden wird, geben Sie nur die Antwort und den zugehörigen Pfad aus. "
    "Keine zusätzlichen Erklärungen oder Kommentare. Falls keine Antwort in den Dateien "
    "enthalten ist, geben Sie nichts aus."
)

def _read_text_safe(p: Path) -> str:
    try:
        return p.read_text(encoding="utf-8")
    except Exception:
        return p.read_text(encoding="utf-8", errors="ignore")

def _gather_files(copy_dir: str, k: int) -> List[Path]:
    d = Path(copy_dir)
    if not d.exists():
        return []
    files = [
        p for p in d.iterdir()
        if p.is_file()
        and p.name != "manifest.json"
        and p.suffix.lower() not in {".json", ".png", ".jpg", ".jpeg", ".gif", ".pdf"}
    ]
    files.sort()
    return files[:k]

def _normalize_newlines(text: str) -> str:
    """Collapse multiple blank lines into a single blank line."""
    # Replace Windows line endings first
    text = text.replace("\r\n", "\n").replace("\r", "\n")
    # Collapse more than 2 newlines into exactly 2
    return re.sub(r"\n\s*\n+", "\n\n", text)

def make_payload_text(copy_dir: str, query: str, k: int = 20, max_chars: int = 18_000) -> str:
    """
    Build the payload text similar to the example in your screenshot.
    - Uses the provenance header already inside each file (no duplicate).
    - Cleans up multiple blank lines.
    - Trims total payload to `max_chars`.
    """
    header = f"{INSTRUCTIONS}\n\nFrage: [{query} ]\n\nDateien:\n"
    remaining = max_chars - len(header)
    if remaining <= 0:
        return header.rstrip()

    blocks: List[str] = []
    files = _gather_files(copy_dir, k)
    if not files:
        return header + "(keine Dateien gefunden)"

    for i, p in enumerate(files, start=1):
        text = _read_text_safe(p)
        if not text:
            continue

        # Clean newlines
        text = _normalize_newlines(text)

        # Prefix only the file marker (no extra provenance line)
        block_header = f"\nfile:{i}.\n"

        # Budget per file
        budget = remaining - len(block_header)
        if budget <= 0:
            break

        body = text if len(text) <= budget else text[:budget]
        block = block_header + body + "\n"
        blocks.append(block)
        remaining -= len(block)

        if remaining <= 0:
            break

    payload = header + "".join(blocks)
    if len(payload) > max_chars:
        payload = payload[: max_chars - 4] + "...\n"
    return payload.rstrip() + "\n"

def make_payload_file(copy_dir: str, query: str, out_file: str,
                      k: int = 20, max_chars: int = 18_000) -> str:
    payload = make_payload_text(copy_dir=copy_dir, query=query, k=k, max_chars=max_chars)
    out_path = Path(out_file)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(payload, encoding="utf-8", newline="\n")
    return str(out_path)